\subsubsection{Comment Linux gère le suport d'un processeur}

Pour gérer la compatibilité avec un processeur, le \textit{bootloader} charge au démarrage de Linux le fichier \textit{Device Tree} qui contient les informations sur le matériel présent sur la carte. Ce fichier est ensuite utilisé par le noyau Linux pour initialiser le matériel. Dans notre cas, le fichier \texttt{rock960-rk3399.dts} charge le fichier \texttt{rk3399.dtsi} qui contient les informations sur le processeur. On peut y trouver les informations sur la connectique, les périphériques, les contrôleurs, les bus, etc.
La partie nous intéressant est celle sur la structure des processeurs qui se trouve dans le fichier \texttt{rk3399.dtsi}. On y trouve les informations sur les différents cœurs du processeur, leur fréquence, leur cache. C'est vers la fin de mon stage que j'ai pu me rendre compte d'un oubli dans le fichier décrivant ce processeur : les caches ne sont pas décrits. Cela a des conséquences sur les algorithmes d'ordonnancement utilisant cette information pour concevoir les clusters de processeurs les plus adaptés. En effet, les caches sont utilisés pour déterminer les coûts de migration d'une tâche d'un cœur à un autre. Sans cette information, les algorithmes d'ordonnancement ne peuvent pas déterminer les coûts de migration et ne peuvent donc pas déterminer les clusters les plus adaptés. 

Dans le listing \ref{annexe:cache} de l'annexe, on peut voir les modifications que j'ai apporté au fichier \texttt{rk3399.dtsi} pour ajouter les informations sur les caches. Je me suis appuyés sur les informations du \textit{datasheet} du processeur pour ajouter ces informations. La manière d'ajouter ces informations n'étais pas documentée mais j'ai pu trouver des exemples d'autres processeurs pour m'aider à ajouter ces informations.

Ces modifications ne sont toujours pas présentes dans la version actuelle du noyau Linux, il y a alors ici une possibilité de soumettre une \textit{pull request} pour ajouter ces informations au noyau Linux. Je me suis renseigné sur la procédure à suivre pour soumettre une \textit{pull request} au noyau Linux et j'ai pu trouver un guide\cite{kernel-contribute} expliquant la procédure à suivre. Cependant je n'ai pas eu de réponses au patch que j'ai soumis\footnote{Patch envoyé à : <linux-rockchip@lists.infradead.org> et <linux-arm-kernel@lists.infradead.org>}.


De plus, ces informations ne sont pas indispensables pour le fonctionnement de Linux sur ce processeur et ne sont donc pas une priorité pour les développeurs du noyau Linux. Il est donc possible que cette \textit{pull request} ne soit pas acceptée : j'ai pu trouver une pull request similaire datant de plusieurs année qui a mis du temsp à être acceptée\footnote{\href{https://github.com/torvalds/linux/commit/618682b350990f8f1bee718949c4b3858711eb58}{https://github.com/torvalds/linux/commit/618682b350990f8f1bee718949c4b3858711eb58}} alors qu'elle s'intéresse à un processeur plus répandu que le RK3399.


\subsubsection{Essais de différentes versions}

Le problème principal que j'ai rencontré est que le noyau \litmus, dont plus de détails sont donné dans la partie \ref{section:litmus}, n'est pas compatible avec les versions récentes du noyau Linux. En effet, la dernière version officielle du noyau \litmus est basé sur la version 4.9.30 du noyau Linux et date de Mai 2017. Cependant, la carte de développement ROCK960 n'est supportée que depuis la version 6.6 du noyau Linux comme en témoigne un commit de septembre 2018\footnote{\href{https://github.com/torvalds/linux/commit/ffb7b25e8ac3c94f61576ca9cbfd0f16ada1be6d}{https://github.com/torvalds/linux/commit/ffb7b25e8ac3c94f61576ca9cbfd0f16ada1be6d}}. Il est donc nécessaire de trouver une version du noyau Linux compatible avec la carte de développement et avec le noyau \litmus.

Comme recommandé par Antoine Bertout, les \textit{mailling lists} de \litmus m'ont permis de trouver d'autres chercheurs ayant patché des versions plus récentes de Linux. Après plusieurs essaais, je me suis arrêté sur la version 5.4 du noyau Linux pour laquelle Joshua Bakita à fait le travail de patcher linux pour le rendre compatible avec \litmus. J'ai pu trouver son travail sur son \textit{github}\footnote{\href{https://github.com/JoshuaJB/litmus-rt/tree/linux-5.4-litmus}{Depôt de code de linux-5.4-litmus}}. 

J'ai moi même essayer de réaliser ce travail pour une autre version de Linux, celle fournie par le fabriquant de la carte de développement. En effet, je n'ai jamais pu faire fonctionner le WiFi de la carte avec une autre version de Linux que celle faite par 96Boards, c'est pourquoi j'ai tenter de patcher cette version de Linux avec les commits nécessaires pour faire fonctionner \litmus. Cependant j'ai rencontré de nombreux problèmes, à la fois lors de la compilation, et lors du fonctionnement de ma version patché de Linux. C'est donc pourquoi j'ai arrêté ce développement pour me concentrer sur la version de Joshua Bakita. Ma compréhension du noyau Linux n'étais pas suffisante pour comprendre les problèmes que je rencontrais et j'ai donc préféré me concentrer sur la version du noyau patché qui fonctionnait.

Je n'ai pas testé le bon fonctionnement de toutes les fonctionnalités de la carte sous cette version de Linux (HDMI, USB, GPU, etc.) car je n'en avait pas besoin pour mon développement et que je n'avais pas le temps de tester toutes les fonctionnalités de la carte. Dans cette version le WiFi ne fonctionne pas, cela aurait été utile afin d'accélérer le développement lors de mon stage : téléverser les fichiers sur la carte de développement aurait été plus rapide. Cependant, le WiFi n'est pas indispensable pour le fonctionnement de la carte et je n'ai donc continuer ainsi.

Cette étape d'essais de versions et de drivers pour le WiFi étais fastidieuse et malgré l'existence d'outils pour accélérer cela comme \textit{Yocto} ou \textit{Buildroot}, je n'ai pas eu le temps de les utiliser. En effet, ces outils permettent de compiler un système d'exploitation Linux complet pour une carte de développement donnée. Cependant, il faut alors configurer ces outils pour qu'ils utilisent les bons drivers et les bonnes versions de Linux. Cela aurait donc nécessité de comprendre comment ces outils fonctionnent et comment les configurer pour qu'ils utilisent les bons drivers et les bonnes versions de Linux. Cela aurait été utile pour accélérer le développement mais j'ai préféré me concentrer sur le développement de l'ordonnanceur plutôt que sur la configuration de ces outils.